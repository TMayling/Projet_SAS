/* ----------------------------------------- */
/* -- PARTIE 1 : PREPARATION DES DONNEES --  */
/* ----------------------------------------- */

/* 1. ---- Création de la librairie ----*/

options validvarname=any; /*Evite les erreurs de conversions dans les noms de variables*/
LIBNAME Projet '/home/u62478841/Projet_Accident';

/* ---- Import des CSV ----*/

proc import out=Projet.carac
    datafile='/home/u62478841/Projet_Accident/carcteristiques-2021.csv'
    dbms=csv
    replace;
    delimiter=";";
    getnames=YES;
run;

proc import out=Projet.lieux
    datafile='/home/u62478841/Projet_Accident/lieux-2021.csv'
    dbms=csv
    replace;
    delimiter=";";
    getnames=YES;
run;

proc import out=Projet.usagers
    datafile='/home/u62478841/Projet_Accident/usagers-2021.csv'
    dbms=csv
    replace;
    delimiter=";";
    getnames=YES;
run;

proc import out=Projet.veh
    datafile='/home/u62478841/Projet_Accident/vehicules-2021.csv'
    dbms=csv
    replace;
    delimiter=";";
    getnames=YES;
run;

/* 2. --- Jointure des fichiers --- */
	
	/*Proc sort pour faire les jointures*/
	
PROC SORT data = Projet.carac;
by Num_Acc;
RUN;

PROC SORT data = Projet.lieux;
by Num_Acc;
RUN;

PROC SORT data = Projet.veh;
by Num_Acc id_vehicule; /*On ajoute l'id_vehicule car un accident peut concerner plusieurs véhicules */ 
RUN;

PROC SORT data = Projet.usagers;
by Num_Acc id_vehicule;
RUN;

	/*Jointures*/
	
DATA Projet.data_prep; 
  Merge Projet.carac Projet.lieux Projet.veh;
  BY Num_Acc; 
RUN;

DATA Projet.data_global;
	Merge Projet.data_prep Projet.usagers;
	BY Num_Acc id_vehicule;
RUN;

/* 3. --- Traitement des données ---*/

	/* Remplacer les -1 par des null */

data Projet.data_global;
set Projet.data_global;
array Var _CHARACTER_; /*On prend toutes les variables en varchar*/
            do over Var;
            if Var=-1 then Var=.;
            end;
run ;

	/* Changement des types */

proc contents
     data = Projet.data_global
          noprint
     out = vars1 (keep = name type);
run;

proc sql /* noprint */;

     select name
     into :numerics
          separated by ' '
     from vars1
     where name in("lat","long","nbv","pr1","lartpc","larrout","vma","occutc");

* On créer une liste qui va contenir les noms actuels des colonnes avec un C en plus pour pouvoir remplacer par leurs noms de base;
     select trim(name) || 'C'
     into :characters
          separated by ' '
     from vars1
     where name in("lat","long","nbv","pr1","lartpc","larrout","vma","occutc");

     * On créer une liste nom_colonne = nom_colonne_C;
     select cats(name, ' = ' , name, 'C')
     into :conversions
          separated by ' '
     from vars1
     where name in("lat","long","nbv","pr1","lartpc","larrout","vma","occutc");

     quit;

* On remplace les virgules par des points pour éviter les soucis de conversions;
data Projet.data_global;
	 set Projet.data_global;
	 
	 array nums[*] &numerics;

     do i = 1 to dim(nums);
          nums[i] = tranwrd(nums[i], ',', '.');
     end;
run;

* Au lieu d'écrire nom_colonne = nom_colonne_C pour toutes les variables, on utilise notre liste créée précédemment;
data Projet.data_global;
	 set Projet.data_global;
     rename &conversions;
run;

* On change les types;
data Projet.data_global;
     set Projet.data_global;

     array nums[*] &numerics;
     array chars[*] &characters;

     do i = 1 to dim(nums);
          nums[i] = input(chars[i], BEST32.);
     end;
*On drop les colonnes avant la conversion;
     drop i &characters;
run;

	/*Suppression des doublons*/

proc sort data=Projet.data_global out=Projet.data_global nodupkey;
    by _all_;
run;

	/*Détection des outliers*/
proc univariate data=Projet.data_global robustscale plot;
run;

/*Analyse d'une valeur extrême pour la variable lartpc*/
proc sql;
select *
from Projet.data_global
where lartpc = 40;
quit;

/* ----------------------------------------- */
/* ---- PARTIE 2 : ANALYSE DESCRIPTIVE ----  */
/* ----------------------------------------- */

/* --- 1. Nombre d'accidents par département et par localisation ---*/
/* PROC SAS */


				/*A faire : tableau croisé, cf TD6 pour modèle*/


/* PROC SQL */
/* Départements avec le plus d'accidents */
PROC SQL;
SELECT count(distinct Num_acc) as nb_accidents,
dep
from Projet.data_global
group by dep
order by nb_accidents desc;
QUIT;

/* Plus d'accidents en agglomération que hors agglomération */
PROC SQL;
SELECT count(distinct Num_acc) as nb_accidents,
agg
from Projet.data_global
group by agg
order by nb_accidents desc;
QUIT;


/* --- 2. Est-ce-que les conditions d'environnement ont un impact sur le nombre d'accidents ? --- */

	/* A faire : prendre les variables : lum, atm, surf
	regarder le nombre d'accident pour chaque modalité et faire une analyse rapide
	trier par nombre décroissant d'accident pour voir les modalités qui ressortent le plus*/

	/*A faire en proc SAS ou proc SQL selon préférence*/


/* --- 3. Représenter graphiquement les lieux où se sont produits les accidents ---*/

	/* A faire : Utiliser les cartes sur SAS
	On dispose de deux champs : lat (latitude) et Long (longitude) pour les coordonnées gps
	Essayer de voir si on peut utiliser la carte SAS pour représenter le nombre d'accident
	
	Si c'est pas possible, on zappe la question. On en a déjà beaucoup donc c'est pas grave
	
	Pour utiliser les cartes,s'aider de l'onglet Tâche et Utilitaire > Tâches > Carte */

/* ----------------------------------------- */
/* --- PARTIE 3 : ANALYSE INFERENTIELLE ---  */
/* ----------------------------------------- */

/* 1. --- Test d'indépendance entre deux variables qualitatives --- */

/*    Var1 : catu (catégorie usager 1: Conducteur, 2: Passager, 3: Piéton)
	  Var2 : grav (gravité de l'accident 1: Indemne, 2: Tué, 3: Blessé Hospitalisé, 4: Bléssé Léger)

  Nous allons réaliser un test du Khi-deux avec les hypothèses suivantes :
	H0 : Il existe un lien entre la catégorie de l'usager et la gravité de l'accident
	H1 : Il n'existe pas de lien

    Tout d'abord, on catégorise nos données pour qu'elles aient le même nombre de modalités.
On va regrouper la modalité 1 et 4 de la variable grav dans un groupe "Accident léger", et les
modalités 2 et 3 dans "Accident grave". De même, nous allons exclure les piétions de l'analyse. 

*/
proc sql;
Select 
case when catu = '1' then 'Conducteur'
     when catu = '2' then 'Passager'
end as catu, 

case when grav = '1' then 'Accident leger'
          when grav = '4' then 'Accident leger' 
     	  when grav = '2' then 'Accident grave' 
     	  when grav = '3' then 'Accident grave' 
end as grav_cate,
count(*) as nb_accident

from Projet.data_global
where catu in("1","2")
and grav in("1","2","3","4")
group by catu, grav_cate
order by grav_cate;
quit;

data Projet.data_khideux;
	 set Projet.data_global;
	 
	 KEEP Num_Acc id_vehicule catu_nom cate_grav;

	 IF grav = '1' THEN cate_grav = 'Accident leger';
	 ELSE IF grav = '4' THEN cate_grav = 'Accident leger';
	 ELSE IF grav = '2' THEN cate_grav = 'Accident grave';
	 ELSE IF grav = '3' THEN cate_grav = 'Accident grave';
	 
	 IF catu = '1' THEN catu_nom = 'Conducteur';
	 ELSE IF catu = '2' THEN catu_nom = 'Passager';
	 
	 WHERE (grav = '1' OR grav = '2' OR grav = '3' OR grav = '4')
	 AND (catu = '1' OR catu = '2');
	 
run;

proc freq data = Projet.data_khideux;
tables catu*cate_grav /chisq ;
run;





/* 2. --- ANOVA --- */
/*Création d'un dataframe avec uniquement les données concernées*/





/* Analyse SQL
Décomposition des gravités de blessure selon la catégorie de victime (en %)
*/
Data Q2_1;
Set Projet.data_global(rename=(Num_acc=Num_acc_old));
Num_acc =  INPUT(Num_acc_old,f8.);
drop Num_acc_old;
RUN;

PROC TABULATE DATA = Q2_1;
   class catu grav;
   Var Num_acc;
   tables catu='Catégorie usager',grav='gravité'*(Num_acc=''*(ROWPCTN=''));
RUN;




/* ----------------------------------------- */
/* ------- PARTIE 4 : CATEGORISATION ------  */
/* ----------------------------------------- */

/* ----------------------------------------- */
/* ------ PARTIE 5 : Autres analyses ------  */
/* ----------------------------------------- */

/* --- Mois avec le plus d'accidents --- */
PROC SQL;
SELECT count(distinct Num_acc) as nb_accidents,
mois
from Projet.data_global
group by mois
order by nb_accidents desc;
QUIT;

/* --- Communes avec le plus d'accidents --- */
PROC SQL OUTOBS=10;
SELECT count(distinct Num_acc) as nb_accidents,
com
from Projet.data_global
group by com
order by nb_accidents desc;
QUIT;

/* --- Nombre d'accidents, de véhicules et de victimes recensés ---*/
PROC SQL;
SELECT count(distinct Num_acc) as nb_accidents,
count(distinct id_vehicule) as nb_vehicules,
count(id_vehicule) as nb_victimes
from Projet.data_global;
QUIT;

/* --- Nombre d'accidents par voiture --- */
PROC SQL OUTOBS=10;
SELECT count(distinct Num_acc) as nb_accidents,
catu
from Projet.data_global
group by catu
order by nb_accidents desc;
QUIT;

